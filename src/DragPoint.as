package{	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.filters.GlowFilter;	import flash.geom.Point;	public class DragPoint extends Sprite	{		private static const COLOR:uint = 0x555555; 		public var isDragging:Boolean;		public var canDragging:Boolean = true;		public function DragPoint(point:Point = null)		{			if (point)			{				this.x = point.x;				this.y = point.y;			}			this.useHandCursor = true;			this.mouseChildren = false;			this.buttonMode = true;			if (stage) init();			else this.addEventListener(Event.ADDED_TO_STAGE, init);		}		private function init(event:Event = null):void		{			this.graphics.lineStyle(2, 0xffffff);			this.graphics.beginFill(COLOR);			this.graphics.drawCircle(0, 0, 6);			this.graphics.endFill();			this.removeEventListener(Event.ADDED_TO_STAGE, init);			this.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownListener);			this.filters = [new GlowFilter(COLOR, 0.4)];			stage.addEventListener(MouseEvent.MOUSE_UP, onMouseUpListener);		}		private function onMouseDownListener(event:MouseEvent):void		{			if (this.canDragging == true)			{				stage.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMoveListener);				this.isDragging = true;			}		}		private function onMouseUpListener(event:MouseEvent):void		{			if (stage && this.isDragging == true)			{				this.isDragging = false;				stage.removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMoveListener);				this.dispatchEvent(new Event(Event.PASTE));			}		}		private function onMouseMoveListener(event:MouseEvent):void		{			event.updateAfterEvent();			this.x = this.parent.mouseX;			this.y = this.parent.mouseY;			this.dispatchEvent(new Event(Event.CHANGE));		}		public function destroy():void		{			if (stage) stage.removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMoveListener);			this.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDownListener);		}	}}